<template>
  <div class="customName nodeStyle">
    <head>
      <VIcon class="headIcon color-primary">arrow-right-circle</VIcon>
      <span class="txt">{{ $t('editor.nodeSettings') }}</span>
    </head>
    <div class="nodeBody">
      <!-- <div class="head-btns">
				<el-button v-if="disabled" class="e-button" type="primary" @click="seeMonitor">
					{{ $t('dataFlow.button.viewMonitoring') }}
				</el-button>
			</div> -->
      <el-form class="e-form" label-position="top" :model="model" ref="form" :disabled="disabled">
        <!-- <span class="addTxt">+新建文件</span> -->
        <el-form-item :label="$t('editor.choose') + ' Custom'" prop="connectionId" :rules="rules" required>
          <el-select
            :filterable="!databaseLoading"
            :loading="databaseLoading"
            v-model="model.connectionId"
            :placeholder="$t('editor.cell.data_node.custom.chooseCustomName')"
            :clearable="true"
            @change="handlerConnectionChange"
          >
            <el-option
              v-for="(item, idx) in databases"
              :label="`${item.name} (${$t('connection.status.' + item.status) || item.status})`"
              :value="item.id"
              v-bind:key="idx"
            ></el-option>
          </el-select>
        </el-form-item>
        <el-form-item
          :label="$t('editor.cell.data_node.table.form.table.label')"
          prop="tableName"
          :rules="rules"
          required
        >
          <div class="flex-block">
            <el-select
              filterable
              allow-create
              default-first-option
              clearable
              class="e-select"
              v-model="model.tableName"
              :placeholder="$t('editor.cell.data_node.table.form.table.placeholder')"
              size="mini"
            >
              <el-option
                v-for="(item, idx) in schemas"
                :label="`${item.table_name}`"
                :value="item.table_name"
                v-bind:key="idx"
              ></el-option>
            </el-select>
            <ClipButton :value="model.tableName"></ClipButton>
          </div>
        </el-form-item>
        <!-- <el-form-item :label="$t('editor.cell.data_node.collection.form.pk.label')" required>
					<MultiSelection
						v-model="model.primaryKeys"
						:options="primaryKeyOptions"
						:placeholder="$t('editor.cell.data_node.collection.form.pk.placeholder')"
					></MultiSelection>
				</el-form-item> -->
        <el-form-item
          required
          :label="$t('editor.cell.data_node.collection.form.initialSyncOrder.keep')"
          v-if="isSourceDataNode"
        >
          <div class="flex-block">
            <el-switch
              v-model="model.enableInitialOrder"
              style="margin-right: 20px"
              @change="model.initialSyncOrder = 0"
            ></el-switch>
            <el-input-number
              v-if="model.enableInitialOrder"
              v-model="model.initialSyncOrder"
              controls-position="right"
              :min="1"
              size="mini"
            ></el-input-number>
          </div>
        </el-form-item>
        <el-form-item>
          <div class="flex-block fr" v-if="model.connectionId && model.tableName">
            <el-button
              class="fr"
              type="success"
              size="mini"
              v-if="isSourceDataNode || !showFieldMapping"
              @click="hanlderLoadSchema"
            >
              <VIcon v-if="reloadModelLoading">loading-circle</VIcon>
              <span v-if="reloadModelLoading">{{ $t('dataFlow.loadingText') }}</span>
              <span v-else>{{ $t('dataFlow.updateModel') }}</span>
            </el-button>
            <FieldMapping
              v-else
              ref="fieldMapping"
              class="fr"
              :dataFlow="dataFlow"
              :showBtn="true"
              :isFirst="model.isFirst"
              :isDisable="disabled"
              :hiddenFieldProcess="true"
              :stageId="stageId"
              @update-first="returnModel"
            ></FieldMapping>
          </div>
        </el-form-item>
      </el-form>
      <div class="e-entity-wrap" style="text-align: center">
        <entity :schema="convertSchemaToTreeData(mergedSchema)" :editable="false"></entity>
      </div>
    </div>
    <relatedTasks :taskData="taskData" v-if="disabled"></relatedTasks>
    <el-dialog :title="$t('message.prompt')" :visible.sync="dialogVisible" :close-on-click-modal="false" width="30%">
      <span>{{ $t('editor.ui.nodeLoadSchemaDiaLog') }}</span>
      <span slot="footer" class="dialog-footer">
        <el-button @click="dialogVisible = false">{{ $t('message.cancel') }}</el-button>
        <el-button type="primary" @click="confirmDialog">{{ $t('message.confirm') }}</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
import _ from 'lodash'
import factory from '../../../api/factory'
// import MultiSelection from '../../../components/MultiSelection';
import RelatedTasks from '../../../components/relatedTasks'
import ClipButton from '@/components/ClipButton'
import FieldMapping from '@/components/FieldMapping'
import Entity from '../link/Entity'
import ws from '../../../api/ws'
import { convertSchemaToTreeData, uuid } from '../../util/Schema'
import VIcon from '@/components/VIcon'
let connectionApi = factory('connections')
// let editorMonitor = null;
export default {
  name: 'CustomNode',
  components: { Entity, ClipButton, RelatedTasks, VIcon, FieldMapping },
  props: {
    connection_type: {
      type: String,
      default: 'source'
    }
  },
  data() {
    return {
      taskData: {
        id: '',
        tableName: ''
      },
      reloadModelLoading: false,
      dialogVisible: false,
      schemas: [],
      disabled: false,
      isSourceDataNode: true,
      databases: [],
      databaseLoading: false,
      rules: {
        connectionId: [
          {
            required: true,
            trigger: 'blur',
            message: this.$t('editor.cell.data_node.custom.chooseCustomName')
          }
        ]
      },
      dataNodeInfo: {},
      model: {
        connectionId: '',
        tableName: '',
        type: 'custom_connection',
        databaseType: 'custom_connection',
        isFirst: true
      },
      scope: '',
      dataFlow: '',
      stageId: '',
      showFieldMapping: false,
      mergedSchema: null,
      primaryKeyOptions: []
    }
  },

  async mounted() {
    this.databaseLoading = true
    let result = await connectionApi.get({
      filter: JSON.stringify({
        where: {
          database_type: 'custom_connection'
        },
        fields: {
          name: 1,
          id: 1,
          database_type: 1,
          connection_type: 1,
          status: 1
        },
        order: 'name ASC'
      })
    })

    this.databaseLoading = false
    if (result.data) {
      this.databases = result.data
    }
  },
  watch: {
    model: {
      deep: true,
      handler() {
        this.$emit('dataChanged', this.getData())
      }
    },
    'model.tableName': {
      immediate: true,
      handler() {
        if (this.schemas.length > 0) {
          if (this.model.tableName) {
            let schema = this.schemas.filter(s => s.table_name === this.model.tableName)
            schema =
              schema && schema.length > 0
                ? schema[0]
                : {
                    table_name: this.model.tableName,
                    cdc_enabled: true,
                    meta_type: 'collection',
                    fields: [
                      {
                        autoincrement: false,
                        columnSize: 0,
                        dataType: 7,
                        data_type: 'OBJECT_ID',
                        field_name: '_id',
                        id: uuid(),
                        is_nullable: true,
                        javaType: 'String',
                        key: 'PRI',
                        original_field_name: '_id',
                        precision: 0,
                        primary_key_position: 1,
                        scale: 0,
                        table_name: this.model.tableName
                      }
                    ]
                  }

            let fields = schema.fields || []
            // let primaryKeys = fields
            // 	.filter(f => f.primary_key_position > 0)
            // 	.map(f => f.field_name)
            // 	.join(',');
            this.primaryKeyOptions = fields.map(f => f.field_name)
            // if (primaryKeys) {
            // 	this.model.primaryKeys = primaryKeys;
            // } else {
            // 	this.model.primaryKeys = '';
            // }
            this.$emit('schemaChange', _.cloneDeep(schema))
          }
        }

        this.taskData.tableName = this.model.tableName
      }
    },
    mergedSchema: {
      handler() {
        if (this.mergedSchema && this.mergedSchema.fields && this.mergedSchema.fields.length > 0) {
          let fields = this.mergedSchema.fields
          this.primaryKeyOptions = fields.map(f => f.field_name)
          // if (!this.model.primaryKeys) {
          // 	let primaryKeys = fields.filter(f => f.primary_key_position > 0).map(f => f.field_name);
          // 	if (primaryKeys.length > 0) this.model.primaryKeys = primaryKeys.join(',');
          // }
        }
      }
    }
  },
  methods: {
    convertSchemaToTreeData,
    setData(data, cell, dataNodeInfo, vueAdapter) {
      if (data) {
        this.scope = vueAdapter?.editor?.scope
        this.getDataFlow()
        this.stageId = cell.id
        _.merge(this.model, data)
        let param = {
          stages: this.dataFlow?.stages,
          stageId: this.stageId
        }
        this.$api('DataFlows')
          .tranModelVersionControl(param)
          .then(data => {
            this.showFieldMapping = data?.data[this.stageId]
          })
      }
      this.isSourceDataNode = dataNodeInfo && (dataNodeInfo.isSource || !dataNodeInfo.isTarget)
      this.mergedSchema = cell.getOutputSchema()
      cell.on('change:outputSchema', () => {
        this.mergedSchema = cell.getOutputSchema()
        this.getDataFlow()
      })

      // editorMonitor = vueAdapter.editor;
    },
    getData() {
      let result = _.cloneDeep(this.model)
      if (result.connectionId) {
        let database = this.databases.filter(db => db.id === result.connectionId)
        if (database && database.length > 0) {
          result.name = database[0].name
        }
      }
      return result
    },

    handlerConnectionChange() {
      for (let i = 0; i < this.databases.length; i++) {
        if (this.model.connectionId === this.databases[i].id) {
          this.model.databaseType = this.databases[i]['database_type']
        }
      }
      this.loadDataModels(this.model.connectionId)
      if (this.model.connectionId) {
        this.taskData.id = this.model.connectionId
        this.taskData.tableName = this.model.tableName
      }
    },
    loadDataModels(connectionId) {
      if (!connectionId) {
        return
      }
      let self = this
      connectionApi.get([connectionId]).then(result => {
        if (result.data) {
          let schemas = (result.data.schema && result.data.schema.tables) || []
          schemas = schemas.sort((t1, t2) =>
            t1.table_name > t2.table_name ? 1 : t1.table_name === t2.table_name ? 0 : -1
          )
          self.schemas = schemas
        }
      })
    },
    setDisabled(disabled) {
      this.disabled = disabled
    },
    // seeMonitor() {
    // 	editorMonitor.goBackMontior();
    // },

    // 更新模型点击弹窗
    hanlderLoadSchema() {
      this.dialogVisible = true
    },

    // 确定更新模型弹窗
    confirmDialog() {
      this.reloadModelLoading = true
      let params = {
        type: 'reloadSchema',
        data: {
          tables: [
            {
              connId: this.model.connectionId,
              tableName: this.model.tableName
              // userId: this.$cookie.get('user_id')
            }
          ]
        }
      }

      ws.ready(() => {
        ws.send(params)
      })
      let self = this,
        schema = null,
        templeSchema = []
      ws.on('execute_load_schema_result', res => {
        if (res.status === 'SUCCESS' && res.result && res.result.length) {
          templeSchema = res.result
          this.reloadModelLoading = false
          self.$message.success(this.$t('message.reloadSchemaSuccess'))
        } else {
          self.$message.error(this.$t('message.reloadSchemaError'))
        }
        this.reloadModelLoading = false
        if (templeSchema && templeSchema.length) {
          templeSchema.forEach(item => {
            if (item.connId === this.model.connectionId && item.tableName === this.model.tableName) {
              schema = item.schema
            }
          })
        }
        self.$nextTick(() => {
          self.$emit('schemaChange', _.cloneDeep(schema))
          this.mergedSchema = schema
        })
      })
      this.dialogVisible = false
    },
    //获取dataFlow
    getDataFlow() {
      this.dataFlow = this.scope.getDataFlowData(true) //不校验
    },
    //接收是否第一次打开
    returnModel(value) {
      this.model.isFirst = value
    }
  }
}
</script>
